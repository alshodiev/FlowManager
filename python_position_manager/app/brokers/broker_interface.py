# broker_interface.py
from abc import ABC, abstractmethod
from typing import Callable, Optional
from dataclasses import dataclass

@dataclass
class TradeConfirmationMessage:
    order_id: int
    client_order_id: str # The ID generated by PM
    symbol: str
    filled_quantity: int
    side_is_buy: bool # True for buy, False for sell
    price: float
    status: str # e.g., "FILLED", "PARTIALLY_FILLED", "CANCELLED", "REJECTED"

@dataclass
class OrderDetails: # For PM to keep track of its orders sent to broker
    client_order_id: str
    broker_order_id: Optional[int] # ID from the actual broker/OB
    symbol: str
    quantity: int
    side_is_buy: bool
    type: str
    price: Optional[float]
    status: str # e.g. "PENDING_NEW", "NEW", "WORKING", "PENDING_CANCEL"
    filled_quantity: int

class BrokerInterface(ABC):
    @abstractmethod
    def __init__(self, trade_confirmation_callback: Callable[[TradeConfirmationMessage], None]):
        self.trade_confirmation_callback = trade_confirmation_callback

    @abstractmethod
    def submit_order(self, client_order_id: str, symbol: str, quantity: int, side_is_buy: bool, order_type: str = "MARKET", price: Optional[float] = None) -> Optional[int]:
        """
        Submits an order.
        - client_order_id: Unique ID generated by the PositionManager.
        Returns a broker_order_id if accepted immediately, or None and confirmation comes later.
        The broker should call self.trade_confirmation_callback for fills, rejections, cancellations.
        """
        pass

    @abstractmethod
    def cancel_order(self, client_order_id: str) -> bool:
        """
        Requests cancellation of an order using the PM's client_order_id.
        Returns True if cancel request was accepted, False otherwise.
        Confirmation of cancellation (and any partial fills) comes via callback.
        """
        pass

    @abstractmethod
    def get_order_details(self, client_order_id: str) -> Optional[OrderDetails]:
        """ PM might use this to query orders it sent, if not tracking everything itself """
        pass

    @abstractmethod
    def start(self):
        """Start any background threads or connections."""
        pass

    @abstractmethod
    def stop(self):
        """Stop background threads, close connections, and process pending tasks."""
        pass